var h=Object.assign;import{createEventEmitter as o}from"../events.js";export const UPDATE_EVENT="@@update";export function normalizeEvent(s){return(t,e)=>(typeof t=="string"&&(t={type:t,data:e}),s(t))}const n=(s,t)=>{for(const e in s)t.set(e,s[e])};export const clone=s=>JSON.parse(JSON.stringify(s));export class Store{constructor(t={}){this.mutations=new Map,this.actions=new Map,this.events=new Map,this.emitter=o(),this.eventsPending=!1,this.state={},this.on=this.emitter.on,this.off=this.emitter.off,this.emit=this.emitter.emit,this.dispatch=normalizeEvent(e=>{const i=this.actions;i.has(e.type)&&i.get(e.type)(this,e.data)}),this.commit=normalizeEvent(e=>{const i=this.state,r=this.mutations;r.has(e.type)&&(this.state=h({},i),r.get(e.type)(this.state,e.data),this.triggerEvents(e))}),n(t.mutations,this.mutations),n(t.actions,this.actions),n(t.events,this.events),this.state=t.state,t.plugins&&t.plugins.forEach(e=>e(this))}triggerEvents(t){if(this.eventsPending)return;this.eventsPending=!0,queueMicrotask(()=>{this.emitter.emit(UPDATE_EVENT,t),this.events.forEach((e,i)=>{~e.indexOf(t.type)&&this.emitter.emit(i,t)}),this.eventsPending=!1})}}export function createStore(s){return new Proxy(new Store(s),{get(t,e,i){return t.actions.has(e)?t.actions.get(e).bind(null,t):Reflect.get(t,e,i)}})}
