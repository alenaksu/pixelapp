import{createEventEmitter as r}from"../events.js";export const UPDATE_EVENT="@@update";export function normalizeEvent(e){return(t,s)=>(typeof t=="string"&&(t={type:t,data:s}),e(t))}const n=(e,t)=>{for(const s in e)t.set(s,e[s])};export const clone=e=>JSON.parse(JSON.stringify(e));export class Store{constructor(e={}){this.mutations=new Map,this.actions=new Map,this.events=new Map,this.emitter=r(),this.eventsPending=!1,this.state={},this.on=this.emitter.on,this.off=this.emitter.off,this.dispatch=normalizeEvent(t=>{const s=this.actions;s.has(t.type)&&s.get(t.type)(this,t.data)}),this.commit=normalizeEvent(t=>{const s=this.state,i=this.mutations;i.has(t.type)&&(this.state={...s},i.get(t.type)(this.state,t.data),this.triggerEvents(t))}),n(e.mutations,this.mutations),n(e.actions,this.actions),n(e.events,this.events),this.state=Object.freeze(clone(e.initialState)),e.plugins&&e.plugins.forEach(t=>t(this))}triggerEvents(e){if(this.eventsPending)return;this.eventsPending=!0,queueMicrotask(()=>{this.emitter.emit(UPDATE_EVENT,e),this.events.forEach((t,s)=>{~t.indexOf(e.type)&&this.emitter.emit(s,e)}),this.eventsPending=!1})}}export function createStore(e){return new Proxy(new Store(e),{get(t,s,i){return t.actions.has(s)?t.actions.get(s).bind(null,t):Reflect.get(t,s,i)}})}
