import{createEventEmitter as h}from"../events.js";export const UPDATE_EVENT="@@update";export function normalizeEvent(s){return(t,e)=>(typeof t=="string"&&(t={type:t,data:e}),s(t))}const n=(s,t)=>{for(const e in s)t.set(e,s[e])};export class Store{constructor(s={}){this.mutations=new Map,this.actions=new Map,this.events=new Map,this.emitter=h(),this.updatePending=!1,this.state={},this.on=this.emitter.on,this.off=this.emitter.off,this.dispatch=normalizeEvent(t=>{const e=this.actions,i=this.state;this.state={...i},e.has(t.type)&&e.get(t.type)(this,t.data)}),this.commit=normalizeEvent(t=>{const e=this.state,i=this.mutations;this.state={...e},i.has(t.type)&&i.get(t.type)(this.state,t.data),this.requestUpdate(this.state,e)}),n(s.mutations,this.mutations),n(s.actions,this.actions),n(s.events,this.events),this.state=Object.freeze({...s.initialState}),s.plugins&&s.plugins.forEach(t=>t(this))}requestUpdate(s,t){if(this.updatePending)return;this.updatePending=!0,queueMicrotask(()=>{this.emitter.emit(UPDATE_EVENT,{state:s,prevState:t}),this.events.forEach((e,i)=>{const r=e.reducer(t),a=e.reducer(s);e.compare(r,a)||this.emitter.emit(i,{value:a,prevValue:r})}),this.updatePending=!1})}}export function createStore(s){return new Proxy(new Store(s),{get(t,e,i){return t.actions.has(e)?t.actions.get(e).bind(null,t):Reflect.get(t,e,i)}})}
