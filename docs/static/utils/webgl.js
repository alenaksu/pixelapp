export function createShader(e,n,t){const r=e.createShader(n);e.shaderSource(r,t),e.compileShader(r);const a=e.getShaderParameter(r,e.COMPILE_STATUS);return a?r:(console.error(`An error occured compiling the shader: ${e.getShaderInfoLog(r)}`),e.deleteShader(r),null)}export function createFramebuffer(e,n,t,r=null,a={}){const o=createTexture(e,n,t,r,a),f=e.createFramebuffer();return e.bindFramebuffer(e.FRAMEBUFFER,f),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0),{texture:o,buffer:f}}export function createArrayBuffer(e,n){const t=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),t}export function setAttribArray(e,n,t,r=e.FLOAT){const a=e.getAttribLocation(e.getParameter(e.CURRENT_PROGRAM),n);e.enableVertexAttribArray(a),e.vertexAttribPointer(a,t,r,!1,0,0)}export function createProgram(e,n,t){const r=e.createProgram();e.attachShader(r,n),e.attachShader(r,t),e.linkProgram(r);const a=e.getProgramParameter(r,e.LINK_STATUS);return a||(console.error(`Unable to initialize the shader program: ${e.getProgramInfoLog(r)}`),e.deleteProgram(r)),r}export function createTexture(e,n,t,r=null,{wrap:a=e.CLAMP_TO_EDGE,filter:o=e.NEAREST,type:f=e.UNSIGNED_BYTE}={}){const i=e.createTexture();return e.bindTexture(e.TEXTURE_2D,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,o),r?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n,t,0,e.RGBA,f,null),e.bindTexture(e.TEXTURE_2D,null),i}export function setUniform(e,n,t,r){switch(n){case e.FLOAT:return e.uniform1f(t,r);case e.FLOAT_VEC2:return e.uniform2fv(t,r);case e.FLOAT_VEC3:return e.uniform3fv(t,r);case e.FLOAT_VEC4:return e.uniform4fv(t,r);case e.INT:return e.uniform1i(t,r);case e.INT_VEC2:return e.uniform2iv(t,r);case e.INT_VEC3:return e.uniform3iv(t,r);case e.INT_VEC4:return e.uniform4iv(t,r);case e.BOOL:return e.uniform1i(t,r);case e.BOOL_VEC2:return e.uniform2iv(t,r);case e.BOOL_VEC3:return e.uniform3iv(t,r);case e.BOOL_VEC4:return e.uniform4iv(t,r);case e.FLOAT_MAT2:return e.uniformMatrix2fv(t,!1,r);case e.FLOAT_MAT3:return e.uniformMatrix3fv(t,!1,r);case e.FLOAT_MAT4:return e.uniformMatrix4fv(t,!1,r);case(e.SAMPLER_2D||n==e.SAMPLER_CUBE):return e.uniform1i(t,r);default:throw"unknown type: 0x"+n.toString(16)}}export function setUniforms(e,n){const t=e.getParameter(e.CURRENT_PROGRAM),r=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let a=0;a<r;++a){const{name:o,type:f}=e.getActiveUniform(t,a);if(o in n){const i=e.getUniformLocation(t,o);setUniform(e,f,i,n[o])}}}export function createPlane(){return new Float32Array([-1,1,1,1,-1,-1,1,-1])}export function enableExtensions(e,n){for(const t of n){const r=e.getExtension(t);if(!r)throw new Error(`Extension not available: ${t}`)}}
